/***************************************************************************
                          rwphtml.cpp  -  description
                             -------------------
    begin                : Thu Jun 24 1999
    copyright            : (C) 1999 by Torsten Uhlmann
    email                : TUhlmann@gmx.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include <stdlib.h>
#include <string.h>
#include "gs_rwphtml.h"


GS_RWPHTML::GS_RWPHTML()
{
}


char GS_RWPHTML::ProcessText(char *text, int maxlen, const SWKey * key)
{
	char *to, *from;
	bool inverse = false;
	bool first_letter = false;
	int len;

	len = strlen(text) + 1;	// shift string to right of buffer
	if (len < maxlen) {
		memmove(&text[maxlen - len], text, len);
		from = &text[maxlen - len];
	} else
		from = text;	
	for (to = text; *from; from++) {
		if (*from == '\\') { /* use symbol font to display greek */
			++from;
			first_letter = true;
			strcpy(to,"<I> </I><FONT FACE=\"symbol\">");
			to += strlen(to);
			while (*from != '\\') {
				if ((first_letter)
				    && (*from == 'h')) {
					if (from[1] == 'o') {
						*to++ = 'o';
						first_letter = false;
						++from;
					} else if (from[1] == 'a') {
						*to++ = 'a';
						first_letter = false;
						++from;
					} else if (from[1] == 'w') {
						*to++ = 'w';
						first_letter = false;
						++from;
					} else if (from[1] == 'u') {
						*to++ = 'u';
						first_letter = false;
						++from;
					} else if (from[1] ==
						   -109) {
						*to++ = 'w';
						first_letter = false;
						++from;
					} else if (from[1] ==
						   -120) {
						*to++ = 'h';
						first_letter = false;
						++from;
					} else if (from[1] == 'i') {
						*to++ = 'i';
						first_letter = false;
						++from;
					} else *to++ = 'h';
					++from;
					first_letter = false;
					continue;					
				}
				if ((*from == 't')
				    && (from[1] == 'h')) {
					*to++ = 'q';
					++from;
					++from;					    
					continue;
				}
				if ((*from == 'c')
				    && (from[1] == 'h')) {
					*to++ = 'c';
					++from;
					++from;
					continue;
				}
				if ((*from == 'p')
				    && (from[1] == 'h')) {
				    	++from;
					++from;
					*to++ = 'f';
					continue;
				}
				if (*from == -120) {
					*to++ = 'h';
					++from;
					continue;
				}
				if (*from == -125) {
					*to++ = 'a';
					++from;
					continue;
				}
				if (*from == -109) {
					if(from[1] == 'i') ++from;
					*to++ = 'w';
					++from;
					continue;
				}
				if (*from == ' ')
					first_letter = true;
				if (*from == 's') {
					if(isalpha(from[1])) *to++ = 's';
					else *to++ = 'V';
					++from;
					continue;					
				}
				if (*from == '\'') {					
					continue;
				}
				*to++ = *from;
				++from;
			}
			++from;
			strcpy(to,"</FONT><I> </I>");
			to += strlen(to);
		}
		if ((*from == '#') || (*from == -81)) {	// verse markings (e.g. "#Mark 1:1|")
			inverse = true;
			strcpy(to,"<FONT COLOR=#0000FF>");
			to += strlen(to);			
			continue;
		}
		if ((*from == '|') && (inverse)) {
			inverse = false;
			strcpy(to,"</FONT>");
			to += strlen(to);
			continue;
		}
		if (*from == '{') {
			strcpy(to,"<BR><STRONG>");
			to += strlen(to);
			if ((from - &text[maxlen - len]) > 10) { // not the beginning of the entry
				strcpy(to,"<P>");
				to += strlen(to);
			}
			continue;
		}
		if (*from == '}') {
			// this is kinda neat... DO NOTHING
			strcpy(to," </STRONG>");
			to += strlen(to);
			continue;
		}
		if ((*from == '\n') && (from[1] == '\n')) {
			strcpy(to,"<P>");
			to += strlen(to);
			continue;
		}
		*to++ = *from;
	}
	*to = 0;
	return 0;
}
